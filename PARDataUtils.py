import numpy
import datetime
from scipy.io import netcdf

class WDSSII_Error(Exception) : 
    def __init__(self, typeName) :
        self.badType = typeName

    def __repr__(self) :
        return "Unknown WDSSII PAR datatype %s" % (self.badType)

    def __str__(self) :
        return "Unknown WDSSII PAR datatype %s" % (self.badType)



# All of the loading functions will load the data into (theta, r) coordinates
# They will also produce coordinate data that will be parallel to the data array.
# In other words, you will have three 2-D arrays: data, range gate [Meters], azimuth [DEGREES north]

def LoadPAR_wdssii(filename) :
# This loader will retreive the radar moments data obtained from the wdssii.arrc.nor.ouint computer

    nc = netcdf.netcdf_file(filename, 'r')

    varName = nc.TypeName
    
    azimuths = nc.variables['Azimuth'][:]
    gateWidths = nc.variables['GateWidth'][:]
    beamWidths = nc.variables['BeamWidth'][:]

    missingData = nc.MissingData
    rangeFolded = nc.RangeFolded

    elevAngle = nc.Elevation
    statLat = nc.Latitude
    statLon = nc.Longitude
    scanTime = nc.Time

    parData = None
    aziLen = None
    rangeLen = None

    dataType = nc.DataType

    if (dataType == 'SparseRadialSet') :
        rawParData = nc.variables[varName][:]
        xLoc = nc.variables['pixel_x'][:]
        yLoc = nc.variables['pixel_y'][:]

        (aziLen, rangeLen) = (azimuths.shape[0], yLoc.max() + 1)

        parData = numpy.empty((aziLen, rangeLen))
        parData.fill(numpy.nan)
        parData[xLoc, yLoc] = rawParData

    elif (dataType == 'RadialSet') :
        parData = numpy.array(nc.variables[varName][:])

        (aziLen, rangeLen) = parData.shape

    else :
        raise WDSSII_Error(dataType)

    
    rangeGrid = nc.RangeToFirstGate + (numpy.tile(numpy.arange(rangeLen), (aziLen, 1)) * 
						      numpy.tile(gateWidths, (rangeLen, 1)).T)
    aziGrid = numpy.tile(azimuths, (rangeLen, 1)).T


    # TODO: Maybe we should be using masks?
    parData[numpy.logical_or(parData == missingData, parData == rangeFolded)] = numpy.nan

    nc.close()

    
    return {'vals': parData,
	    'azimuth': aziGrid, 'range_gate': rangeGrid, 'elev_angle': elevAngle,
	    'stat_lat': statLat, 'stat_lon': statLon,
	    'scan_time': scanTime, 'var_name': varName,
	    'gate_length': numpy.median(gateWidths), 'beam_width': numpy.median(beamWidths)}



# TODO: Maybe adjust the code so that a parameterized version of this function can choose
#       what moment(s) to calculate from the data?
def LoadPAR_lipn(filename) :
# This function will load the radar data from a "Level-I Plus" file and produce Reflectivity moments.
# These files were generated by Boon Leng Cheong's program to process PAR data streams.

      nc = netcdf.netcdf_file(filename, 'r')
      
      varName = 'Reflectivity'
      azimuths = nc.variables['Azimuth'][:]
      ranges = nc.variables['Range'][:] * 1000.0    # convert to meters from km

      R0 = nc.variables['R0'][:]
      #R1 = nc.variables['R1_real'][:] + nc.variables['R1_imag'][:] * 1j
      #specWidth = numpy.sqrt(numpy.abs(numpy.log(numpy.abs(R0./R1)))) 
      #            * numpy.sign(numpy.log(numpy.abs(R0./R1))) 
      #            * (nc.Lambda / (2*numpy.sqrt(6)*numpy.pi*nc.PRT))
      parData = (10*numpy.log10(R0 / nc.NoiseFloor) 
		 + numpy.tile(20*numpy.log10(ranges / 1000.0), (len(azimuths), 1)) 
		 + nc.SNRdBtodBZ)

      # Maybe I should be using a mask?
      parData[R0 / nc.NoiseFloor < 5] = numpy.nan

      (rangeGrid, aziGrid) = numpy.meshgrid(ranges, azimuths)

      gateLength = nc.GateSize
      
      elevAngle = nc.Elevation
      statLat = nc.Latitude
      statLon = nc.Longitude
      scanTime = nc.ScanTimeUTC
      
      nc.close()

      return {'vals': parData,
	      'azimuth': aziGrid, 'range_gate': rangeGrid, 'elev_angle': elevAngle,
	      'stat_lat': statLat, 'stat_lon': statLon,
	      'scan_time': scanTime, 'var_name': varName,
	      'gate_length': gateLength, 'beam_width': 1.0}



                                         
def SavePAR_NetCDF(filename, rastPAR, latAxis, lonAxis, scanTime, varName) :
# For saving radar data stored in Lat/Lon coordinates.
    nc = netcdf.netcdf_file(filename, 'w')
    
    # Setting Global Attribute
    nc.title = ('Rasterized PAR ' + varName + ' '
                + datetime.datetime.utcfromtimestamp(scanTime).strftime('%H:%M:%S UTC %m/%d/%Y'))
    
    # Setting the dimensions
    nc.createDimension('lat', len(latAxis))
    nc.createDimension('lon', len(lonAxis))
    nc.createDimension('time', 1)
    
    # Setting the variables
    valueVar = nc.createVariable('value', 'f', ('time', 'lat', 'lon'))
    valueVar.long_name = 'Rasterized PAR ' + varName
    valueVar[:] = rastPAR.reshape((1, len(latAxis), len(lonAxis)))
    
    latVar = nc.createVariable('lat', 'f', ('lat',))
    latVar.units = 'degrees_north'
    latVar.spacing = numpy.diff(latAxis).mean()
    latVar[:] = latAxis
    
    lonVar = nc.createVariable('lon', 'f', ('lon',))
    lonVar.units = 'degrees_east'
    lonVar.spacing = numpy.diff(lonAxis).mean()
    lonVar = lonAxis
    
    timeVar = nc.createVariable('time', 'i', ('time',))
    timeVar.units = 'seconds since 1970-1-1'
    timeVar.assignValue(scanTime)
    
    nc.close()

